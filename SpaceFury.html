<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shooting Game</title>
    <!-- Tailwind CSS (CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      canvas {
        background-color: #1a202c; /* Tailwind gray-900 */
        display: block;
        margin: 0 auto;
      }
      .overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background-color: rgba(26, 32, 44, 0.8);
        z-index: 10;
      }
    </style>
  </head>
  <body class="bg-gray-800 text-white h-screen relative overflow-hidden">
    <!-- Start Menu -->
    <div id="startMenu" class="overlay">
      <h1 class="text-5xl font-bold mb-6">Shooting Game</h1>
      <button
        id="startButton"
        class="px-6 py-3 bg-green-500 hover:bg-green-600 rounded-md text-2xl"
      >
        Start Game
      </button>
    </div>

    <!-- Pause Menu -->
    <div id="pauseMenu" class="overlay hidden">
      <h1 class="text-5xl font-bold mb-6">Paused</h1>
      <button
        id="resumeButton"
        class="px-6 py-3 bg-yellow-500 hover:bg-yellow-600 rounded-md text-2xl"
      >
        Resume Game
      </button>
    </div>

    <!-- Game Over Menu -->
    <div id="gameOverMenu" class="overlay hidden">
      <h1 class="text-5xl font-bold mb-6" id="gameOverText">Game Over</h1>
      <button
        id="restartButton"
        class="px-6 py-3 bg-red-500 hover:bg-red-600 rounded-md text-2xl"
      >
        Restart Game
      </button>
    </div>

    <!-- Score and Health Display -->
    <div class="absolute top-4 left-4 z-20">
      <p id="scoreDisplay" class="text-xl">Score: 0</p>
    </div>

    <!-- Game Canvas -->
    <canvas id="gameCanvas" width="600" height="600"></canvas>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // Get UI elements
      const startMenu = document.getElementById("startMenu");
      const startButton = document.getElementById("startButton");
      const pauseMenu = document.getElementById("pauseMenu");
      const resumeButton = document.getElementById("resumeButton");
      const gameOverMenu = document.getElementById("gameOverMenu");
      const restartButton = document.getElementById("restartButton");
      const scoreDisplay = document.getElementById("scoreDisplay");

      // Game state variables
      let gameState = "start"; // "start", "playing", "paused", "gameOver"
      let score = 0;

      // Player object
      const player = {
        x: canvas.width / 2 - 20,
        y: canvas.height - 40,
        width: 40,
        height: 20,
        speed: 5,
        health: 5, // Increase player health for demonstration
        maxHealth: 5,
      };

      let bullets = [];
      let enemies = [];
      let enemyBullets = []; // Bullets fired by enemies
      let enemySpawnInterval = 2000; // spawn every 2 seconds
      let lastEnemySpawn = Date.now();
      let keys = {};

      // Event Listeners for keyboard
      document.addEventListener("keydown", (e) => {
        if (gameState === "playing") {
          keys[e.key] = true;
          // Use ESC key to pause/resume
          if (e.key === "Escape") {
            togglePause();
          }
        }
      });
      document.addEventListener("keyup", (e) => {
        if (gameState === "playing") {
          keys[e.key] = false;
        }
      });

      // Menu Button Listeners
      startButton.addEventListener("click", () => {
        startGame();
      });
      resumeButton.addEventListener("click", () => {
        resumeGame();
      });
      restartButton.addEventListener("click", () => {
        restartGame();
      });

      // Functions for menus
      function startGame() {
        startMenu.classList.add("hidden");
        gameState = "playing";
        resetGame();
        gameLoop();
      }

      function resumeGame() {
        pauseMenu.classList.add("hidden");
        gameState = "playing";
        gameLoop();
      }

      function togglePause() {
        if (gameState === "playing") {
          gameState = "paused";
          pauseMenu.classList.remove("hidden");
        }
      }

      function gameOver() {
        gameState = "gameOver";
        gameOverMenu.classList.remove("hidden");
      }

      function restartGame() {
        gameOverMenu.classList.add("hidden");
        resetGame();
        gameState = "playing";
        gameLoop();
      }

      // Reset game variables to starting values
      function resetGame() {
        player.x = canvas.width / 2 - 20;
        player.health = player.maxHealth;
        score = 0;
        bullets = [];
        enemies = [];
        enemyBullets = [];
        lastEnemySpawn = Date.now();
        keys = {};
        updateHUD();
      }

      // Update HUD (score and player health bar)
      function updateHUD() {
        scoreDisplay.textContent = `Score: ${score}`;
      }

      // Helper: Draw health bars
      // Draws a bar at (x, y) with a given width, height,
      // current and max values.
      function drawHealthBar(x, y, width, height, current, max) {
        // Draw empty bar background
        ctx.fillStyle = "#2d3748"; // dark background
        ctx.fillRect(x, y, width, height);
        // Calculate fill width
        let fillWidth = (current / max) * width;
        // Change color according to health ratio
        let ratio = current / max;
        if (ratio > 0.66) {
          ctx.fillStyle = "#48bb78"; // green
        } else if (ratio > 0.33) {
          ctx.fillStyle = "#ecc94b"; // yellow
        } else {
          ctx.fillStyle = "#f56565"; // red
        }
        ctx.fillRect(x, y, fillWidth, height);
        // Optional: add a border
        ctx.strokeStyle = "#1a202c";
        ctx.strokeRect(x, y, width, height);
      }

      // Create enemy function. Randomly create a normal enemy,
      // mini-boss, or boss.
      function spawnEnemy() {
        const enemySize = 30;
        let typeRoll = Math.random();
        let enemy = {
          x: Math.random() * (canvas.width - enemySize),
          y: -enemySize,
          width: enemySize,
          height: enemySize,
          speed: 1 + Math.random(), // base speed
          type: "normal",
          health: 1,
          maxHealth: 1,
          shootTimer: 0, // for shooting mini and bosses
        };

        // 10% chance for boss, 20% chance for mini-boss.
        if (typeRoll < 0.1) {
          // Boss
          enemy.type = "boss";
          enemy.width = enemySize * 1.5;
          enemy.height = enemySize * 1.5;
          enemy.x = Math.random() * (canvas.width - enemy.width);
          enemy.speed = 0.5 + Math.random() * 0.5;
          enemy.health = 5;
          enemy.maxHealth = 5;
          enemy.shootInterval = 1500; // milliseconds
        } else if (typeRoll < 0.3) {
          // Mini-Boss
          enemy.type = "mini";
          enemy.width = enemySize * 1.2;
          enemy.height = enemySize * 1.2;
          enemy.x = Math.random() * (canvas.width - enemy.width);
          enemy.speed = 1.5 + Math.random();
          enemy.health = 3;
          enemy.maxHealth = 3;
          enemy.shootInterval = 2000;
        }
        enemies.push(enemy);
      }

      // Player bullet collision detection is the same as before
      function isColliding(rect1, rect2) {
        return (
          rect1.x < rect2.x + rect2.width &&
          rect1.x + rect1.width > rect2.x &&
          rect1.y < rect2.y + rect2.height &&
          rect1.y + rect1.height > rect2.y
        );
      }

      // Update game objects and logic
      function update() {
        // Move player left or right
        if (keys["ArrowLeft"] && player.x > 0) {
          player.x -= player.speed;
        }
        if (keys["ArrowRight"] && player.x + player.width < canvas.width) {
          player.x += player.speed;
        }

        // Player shooting: Space bar
        if (keys[" "] && Date.now() - (player.lastShot || 0) > 300) {
          player.lastShot = Date.now();
          bullets.push({
            x: player.x + player.width / 2 - 2,
            y: player.y,
            width: 4,
            height: 10,
            speed: 7,
          });
        }

        // Update player bullets
        bullets.forEach((bullet, index) => {
          bullet.y -= bullet.speed;
          if (bullet.y < 0) {
            bullets.splice(index, 1);
          }
        });

        // Spawn enemies over time
        if (Date.now() - lastEnemySpawn > enemySpawnInterval) {
          spawnEnemy();
          lastEnemySpawn = Date.now();
        }

        // Update enemy objects
        enemies.forEach((enemy, enemyIndex) => {
          // If enemy is mini or boss, try moving towards player's x
          if (enemy.type === "mini" || enemy.type === "boss") {
            if (player.x + player.width / 2 < enemy.x + enemy.width / 2) {
              enemy.x -= 0.5; // adjust for intelligence
            } else {
              enemy.x += 0.5;
            }
          }

          enemy.y += enemy.speed;

          // Enemy shooting for mini-bosses and bosses
          if (enemy.type === "mini" || enemy.type === "boss") {
            enemy.shootTimer = enemy.shootTimer || 0;
            if (Date.now() - enemy.shootTimer > enemy.shootInterval) {
              enemy.shootTimer = Date.now();
              // Create bullet aimed downward from enemy center
              enemyBullets.push({
                x: enemy.x + enemy.width / 2 - 2,
                y: enemy.y + enemy.height,
                width: 4,
                height: 10,
                speed: enemy.type === "boss" ? 5 : 4,
                damage: enemy.type === "boss" ? 2 : 1,
              });
            }
          }

          // If enemy goes off-screen (bottom), damage player and remove enemy
          if (enemy.y + enemy.height >= canvas.height) {
            player.health--;
            enemies.splice(enemyIndex, 1);
          }

          // Check collision between enemy and player
          if (isColliding(enemy, player)) {
            player.health--;
            enemies.splice(enemyIndex, 1);
          }

          // Check bullets hitting enemy
          bullets.forEach((bullet, bulletIndex) => {
            if (isColliding(enemy, bullet)) {
              enemy.health--;
              // Remove bullet on hit
              bullets.splice(bulletIndex, 1);
              // If enemy health is <= 0, remove enemy and increment score
              if (enemy.health <= 0) {
                // Score based on enemy type
                if (enemy.type === "boss") {
                  score += 50;
                } else if (enemy.type === "mini") {
                  score += 30;
                } else {
                  score += 10;
                }
                enemies.splice(enemyIndex, 1);
              }
            }
          });
        });

        // Update enemy bullets
        enemyBullets.forEach((bullet, index) => {
          bullet.y += bullet.speed;
          // Check collision with player
          if (isColliding(bullet, player)) {
            player.health -= bullet.damage;
            // Remove bullet after hit (for demo purposes; piercing could let it keep going)
            enemyBullets.splice(index, 1);
          } else if (bullet.y > canvas.height) {
            enemyBullets.splice(index, 1);
          }
        });

        updateHUD();

        // End game if player health reaches zero
        if (player.health <= 0) {
          gameOver();
        }
      }

      // Render all objects
      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw player
        ctx.fillStyle = "#48bb78"; // Tailwind green-400
        ctx.fillRect(player.x, player.y, player.width, player.height);
        // Draw player health bar above player
        drawHealthBar(
          player.x,
          player.y - 10,
          player.width,
          5,
          player.health,
          player.maxHealth
        );

        // Draw player bullets
        ctx.fillStyle = "#edf2f7"; // light gray
        bullets.forEach((bullet) => {
          ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        });

        // Draw enemy bullets
        ctx.fillStyle = "#ed8936"; // orange
        enemyBullets.forEach((bullet) => {
          ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        });

        // Draw enemies and their health bars
        enemies.forEach((enemy) => {
          if (enemy.type === "boss") {
            ctx.fillStyle = "#c53030"; // darker red for boss
          } else if (enemy.type === "mini") {
            ctx.fillStyle = "#e53e3e"; // red for mini-boss
          } else {
            ctx.fillStyle = "#f56565"; // red for normal enemy
          }
          ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
          // Draw enemy health bar above
          drawHealthBar(
            enemy.x,
            enemy.y - 8,
            enemy.width,
            4,
            enemy.health,
            enemy.maxHealth
          );
        });
      }

      // Main game loop
      function gameLoop() {
        if (gameState !== "playing") return;
        update();
        render();
        requestAnimationFrame(gameLoop);
      }
    </script>
  </body>
</html>
